package partsList;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.web.PageableDefault;
import org.springframework.data.web.SortDefault;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

import java.util.ArrayList;
import java.util.Map;

@Controller    // This means that this class is a Controller
@RequestMapping(path="/")
public class MainController {

    @Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private RepositoryOfComputerParts repositoryOfComputerParts;


    /*
    * Управлять сортировкой элементов таблицы можно с помощью параметров адресной строки без дополнительных методов.
    * PagingAndSortingRepository поддерживает эту возможность. Например, если мы хотим отсортировать элементы столбца
    * в котором находятся элементы mustHave, то сделать это можно так:
    * http://localhost:8080/all?page=1&sort=mustHave,desc
    * http://localhost:8080/all?page=1&sort=mustHave,asc
    * Параметры передаем с помощью гиперссылок в файле showAll.
    * */


    // Главная страница
    @GetMapping("/main")
    public String mainPage() {
        return "main";
    }

    // Отображаем страницу /add, используем мэппинг Get
    @GetMapping("/add")
    public String main(Map<String, Object> model) {

        Iterable<ComputerPart> computerParts = repositoryOfComputerParts.findAll();

        model.put("computerParts", computerParts);

        return "addpart";
    }

    public int amountOfPCweCanMake() {

        // определяем количество компьютеров, которые можно собрать из имеющихся деталей
        Iterable<ComputerPart> computerParts = repositoryOfComputerParts.findAll();
        // Отбираем в отдельную коллекцию все части с меткой mustHave = true
        ArrayList<ComputerPart> mustHaveCompParts = new ArrayList<>();
        for (ComputerPart x : computerParts) {
            if (x.getMustHave().equals(true)) {
                mustHaveCompParts.add(x);
            }
        }
        // Для того, чтобы определить количество компьютеров которые можно собрать
        // нужно определить деталь с наименьшим количеством
        int amountOfPCweCanMake = mustHaveCompParts.get(0).getAmount();

        for (int i = 0; i < mustHaveCompParts.size() -1; i++) {
            if (amountOfPCweCanMake > mustHaveCompParts.get(i+1).getAmount()) {
                amountOfPCweCanMake = mustHaveCompParts.get(i+1).getAmount();
            }
        }
        return amountOfPCweCanMake;
    }

    // Добавляем запчасти, используем мэппинг Post
    @PostMapping("/add")
    public String add(@RequestParam String name, @RequestParam int amount,
                      @RequestParam Boolean mustHave, Map<String, Object> model) {
        ComputerPart computerPart = new ComputerPart();
        computerPart.setName(name);
        computerPart.setAmount(amount);
        computerPart.setMustHave(mustHave);


        // Проверка есть ли такая запчасть в базе чтобы не добавлять дубликаты
        boolean isItinTheRepository = false;
        Iterable<ComputerPart> computerParts = repositoryOfComputerParts.findAll();
        for (ComputerPart x : computerParts) {
            // Делаем проверку по названию
            if (computerPart.getName().equals(x.getName())) {
                isItinTheRepository = true;
                // редактируем количество суммируя количество новой и текущей детали
                int newAmount = x.getAmount() + computerPart.getAmount();
                x.setAmount(newAmount);
                // добавляем отредактированную деталь в коллекцию
                repositoryOfComputerParts.save(x);
            }
        }
            // Если же такой детали в коллекции не было вообще, то добавляем ее
        if (!isItinTheRepository) {
            repositoryOfComputerParts.save(computerPart);
        }

        computerParts = repositoryOfComputerParts.findAll();
        model.put("computerParts", computerParts);

        return  "redirect:/all";
    }

    public String searchByName(@RequestParam String name, Map<String, Object> model, Map<String, Integer> mod) {

        // Название детали в списке всегда уникально, поэтому в результате поиска всегда будет
        // лишь одно наименование, использовать page в данном случае смысла нет
        ComputerPart part = repositoryOfComputerParts.findByName(name);

        if (part == null) {
            return "nothingWasFound";

        } else {

            model.put("computerPartWeFound", part);

            // mod будет хранить количество компьютеров, которые можно собрать
            int amountOfPCweCanMake = amountOfPCweCanMake();

            mod.put("amountOfPCweCanMake", amountOfPCweCanMake);

            return "foundByName";
        }
    }

    @PostMapping("/all")
    public String searchByNameOnShowAllPage(@RequestParam String name, Map<String, Object> model, Map<String, Integer> mod) {

        String pageName = searchByName(name, model, mod);

        return pageName;
    }

    @PostMapping("/id")
    public String searchByNameOnSortedByIdPage(@RequestParam String name, Map<String, Object> model, Map<String, Integer> mod) {

        String pageName = searchByName(name, model, mod);

        return pageName;
    }

    @PostMapping("/mustHave")
    public String searchByNameOnSortedByMustHavePage(@RequestParam String name, Map<String, Object> model, Map<String, Integer> mod) {

        String pageName = searchByName(name, model, mod);

        return pageName;
    }

    @PostMapping("/name")
    public String searchByNameOnSortedByNamePage(@RequestParam String name, Map<String, Object> model, Map<String, Integer> mod) {

        String pageName = searchByName(name, model, mod);

        return pageName;
    }

    @PostMapping("/amount")
    public String searchByNameOnSortedByAmountPage(@RequestParam String name, Map<String, Object> model, Map<String, Integer> mod) {

        String pageName = searchByName(name, model, mod);

        return pageName;
    }


    @GetMapping("/all")
    public String showAll(@PageableDefault(size = 10) Pageable pageable, Map<String, Object> model,
                          Map<String, Integer> mod) {

        Page<ComputerPart> page = repositoryOfComputerParts.findAll(pageable);
        model.put("computerPartsPage", page);

        // mod будет хранить количество компьютеров, которые можно собрать
        int amountOfPCweCanMake = amountOfPCweCanMake();

        mod.put("amountOfPCweCanMake", amountOfPCweCanMake);

        return "showAll";
    }


    @GetMapping("/mustHave")
    public String sortedByMustHave(@PageableDefault(size = 10) @SortDefault(sort = "mustHave", direction = Sort.Direction.DESC) Pageable pageable,
                                   Map<String, Object> model, Map<String, Integer> mod) {

        // Аннотация @SortDefault, которая отвечает за сортировку, ставится перед параметром Pageable.

        Page<ComputerPart> page = repositoryOfComputerParts.findAll(pageable);
        model.put("computerPartsPage", page);

        // mod будет хранить количество компьютеров, которые можно собрать
        int amountOfPCweCanMake = amountOfPCweCanMake();

        mod.put("amountOfPCweCanMake", amountOfPCweCanMake);

        return "sortedByMustHave";
    }

    @GetMapping("/name")
    public String sortedByName(@PageableDefault(size = 10) @SortDefault(sort = "name", direction = Sort.Direction.ASC) Pageable pageable,
                               Map<String, Object> model, Map<String, Integer> mod) {

        // Аннотация @SortDefault, которая отвечает за сортировку, ставится перед параметром Pageable.

        Page<ComputerPart> page = repositoryOfComputerParts.findAll(pageable);
        model.put("computerPartsPage", page);

        // mod будет хранить количество компьютеров, которые можно собрать
        int amountOfPCweCanMake = amountOfPCweCanMake();

        mod.put("amountOfPCweCanMake", amountOfPCweCanMake);

        return "sortedByName";
    }

    @GetMapping("/id")
    public String sortedByID(@PageableDefault(size = 10) @SortDefault(sort = "id", direction = Sort.Direction.ASC) Pageable pageable,
                             Map<String, Object> model, Map<String, Integer> mod) {

        // Аннотация @SortDefault, которая отвечает за сортировку, ставится перед параметром Pageable.

        Page<ComputerPart> page = repositoryOfComputerParts.findAll(pageable);
        model.put("computerPartsPage", page);

        // mod будет хранить количество компьютеров, которые можно собрать
        int amountOfPCweCanMake = amountOfPCweCanMake();

        mod.put("amountOfPCweCanMake", amountOfPCweCanMake);

        return "sortedByID";
    }

    @GetMapping("/amount")
    public String sortedByAmount(@PageableDefault(size = 10) @SortDefault(sort = "amount", direction = Sort.Direction.ASC) Pageable pageable,
                             Map<String, Object> model, Map<String, Integer> mod) {

        // Аннотация @SortDefault, которая отвечает за сортировку, ставится перед параметром Pageable.

        Page<ComputerPart> page = repositoryOfComputerParts.findAll(pageable);
        model.put("computerPartsPage", page);

        // mod будет хранить количество компьютеров, которые можно собрать
        int amountOfPCweCanMake = amountOfPCweCanMake();

        mod.put("amountOfPCweCanMake", amountOfPCweCanMake);

        return "sortedByAmount";
    }

    @PostMapping("/update")
    public String editComputerPart(@RequestParam String name, @RequestParam int amount,
                      @RequestParam Boolean mustHave, @RequestParam int id, Map<String, Object> model) {

        Iterable<ComputerPart> computerParts = repositoryOfComputerParts.findAll();

        for (ComputerPart x : computerParts) {
            if (!computerParts.equals(null) && x.getId() == id) {
                // редактируем деталь
                x.setName(name);
                x.setAmount(amount);
                x.setMustHave(mustHave);

                // добавляем деталь для редактирования в модель
                model.put("computerPartWeWantToEdit", x);

                // вносим отредактированную деталь в коллекцию
                repositoryOfComputerParts.save(x);
            }
        }

        return  "redirect:/all";
    }

    @GetMapping("/update")
    public String showComputerPartWeWantToEdit(@RequestParam int id, Map<String, Object> model) {

        Iterable<ComputerPart> computerParts = repositoryOfComputerParts.findAll();
        // ищем запчасть по id
        for (ComputerPart x : computerParts) {
            if (computerParts != null && x.getId() == id) {

                // добавляем книгу для редактирования в модель
                model.put("computerPartWeWantToEdit", x);
            }
        }
        return "edit";
    }

    @RequestMapping("/remove")
    public String removeComputerPart(@RequestParam int id) {
        Iterable<ComputerPart> computerParts = repositoryOfComputerParts.findAll();

        for (ComputerPart x : computerParts) {
            if (!computerParts.equals(null) && x.getId() == id) {
                repositoryOfComputerParts.delete(x);
            }
        }
        return  "redirect:/all";
    }
}
